{"name": "Serigrafi Makinesi - Wokwi Simulation","description": "Wokwi project to simulate the Serigrafi Makinesi firmware (Arduino Mega + ST7920 128x64 + rotary encoder + pedal button).","version": "1.0.0","board": "arduino-mega","files": [{"name": "sketch.ino","content": "#include <U8g2lib.h>\n#include <ClickEncoder.h>\n#include <EEPROM.h>\n\n// Wokwi / web sim için TimerOne kaldırıldı.\n// encoder.service() loop içinde çağırılıyor.\n\n// LCD (ST7920 SPI 128x64)\nU8G2_ST7920_128X64_F_SW_SPI u8g2(U8G2_R0, /* clock=*/13, /* data=*/11, /* cs=*/10, U8X8_PIN_NONE);\n\n// Rotary Encoder\n#define ENCODER_A   31\n#define ENCODER_B   33\n#define ENCODER_BTN 35\nClickEncoder encoder(ENCODER_A, ENCODER_B, ENCODER_BTN, 4);\nvolatile int16_t encLast = 0;\n\n// Parametreler (EEPROM adresleri)\n#define EEPROM_STEP_SPEED_ADDR   0\n#define EEPROM_STEP_DIST_ADDR    2\n#define EEPROM_RAGLE_TIME_ADDR   4\n#define EEPROM_PISTON_TIME_ADDR  6;\n\nunsigned int stepSpeed = 700;   // us\nunsigned int stepDist  = 1000;  // adım\nunsigned int ragleTime = 200;   // ms\nunsigned int pistonTime = 200;  // ms\n\n// Menü ve modlar\nenum MainMenu { MENU_OTOMATIK, MENU_TEST, MENU_AYAR, MENU_COUNT };\nbyte mainMenuIndex = 0;\nbyte ayarMenuIndex = 0;\nbyte testMenuIndex = 0;\n\nenum State { MAIN_MENU, OTOMATIK, TEST, AYAR, ERROR } state = MAIN_MENU;\nbyte donusYon = 0; // 0: sağdan sola, 1: soldan sağa\nchar statusMsg[32] = "";\n\nconst char *mainMenuTexts[] = { "Otomatik Mod", "Test Modu", "Ayarlar" };\nconst char *ayarMenuNames[] = {\n  "Step Hiz(us):", "Step Adim:", "Ragle Bekle(ms):", "Piston Bekle(ms):"\n};\nconst byte AYAR_MENU_COUNT = 4;\n\n// Makine Pinleri (örnek, değiştirilebilir)\nconst int anaPistonYukariSensor = 2;\nconst int anaPistonAsagiSensor  = 3;\nconst int raglePistonYukariSensor = 4;\nconst int raglePistonAsagiSensor  = 5;\nconst int stepSagSensor = 6;\nconst int stepSolSensor = 7;\nconst int pedalButon = 8; // LOW: Basili\n\nconst int anaPistonA = 22;\nconst int anaPistonB = 23;\nconst int raglePistonA = 24;\nconst int raglePistonB = 25;\nconst int stepPin = 26;\nconst int dirPin  = 27;\nconst int enablePin = 28;\n\nvoid setup() {\n  u8g2.begin();\n\n  pinMode(ENCODER_BTN, INPUT_PULLUP);\n\n  pinMode(anaPistonYukariSensor, INPUT);\n  pinMode(anaPistonAsagiSensor, INPUT);\n  pinMode(raglePistonYukariSensor, INPUT);\n  pinMode(raglePistonAsagiSensor, INPUT);\n  pinMode(stepSagSensor, INPUT);\n  pinMode(stepSolSensor, INPUT);\n  pinMode(pedalButon, INPUT_PULLUP);\n\n  pinMode(anaPistonA, OUTPUT);\n  pinMode(anaPistonB, OUTPUT);\n  pinMode(raglePistonA, OUTPUT);\n  pinMode(raglePistonB, OUTPUT);\n  pinMode(stepPin, OUTPUT);\n  pinMode(dirPin, OUTPUT);\n  pinMode(enablePin, OUTPUT);\n\n  // EEPROM'dan oku (varsayılan değerler)\n  stepSpeed = EEPROMReadInt(EEPROM_STEP_SPEED_ADDR, 700);\n  stepDist = EEPROMReadInt(EEPROM_STEP_DIST_ADDR, 1000);\n  ragleTime = EEPROMReadInt(EEPROM_RAGLE_TIME_ADDR, 200);\n  pistonTime = EEPROMReadInt(EEPROM_PISTON_TIME_ADDR, 200);\n\n  digitalWrite(enablePin, LOW); // Step aktif (sürücüye göre değişebilir)\n  tumPistonlarYukari();\n  strcpy(statusMsg, "Hazir");\n\n  encLast = encoder.getValue();\n}\n\nvoid loop() {\n  // TimerOne yoksa enkoder servisini loop içinde çağır\n  encoder.service();\n\n  switch (state) {\n    case MAIN_MENU:   handleMainMenu(); break;\n    case OTOMATIK:    otomatikModu(); break;\n    case TEST:        testModu(); break;\n    case AYAR:        ayarMenusu(); break;\n    case ERROR:       hataEkrani(); break;\n  }\n}\n\n/******************* ANA MENÜ *********************/\nvoid handleMainMenu() {\n  int16_t enc = encoder.getValue();\n  if (enc != encLast) {\n    int diff = enc - encLast;\n    encLast = enc;\n    mainMenuIndex = (mainMenuIndex + diff + MENU_COUNT) % MENU_COUNT;\n  }\n  ClickEncoder::Button b = encoder.getButton();\n  if (b == ClickEncoder::Clicked) {\n    if (mainMenuIndex == 0) { state = OTOMATIK; strcpy(statusMsg, "Bekliyor"); }\n    else if (mainMenuIndex == 1) { state = TEST; testMenuIndex = 0; }\n    else if (mainMenuIndex == 2) { state = AYAR; ayarMenuIndex = 0; }\n    delay(200);\n  }\n  // LCD\n  u8g2.clearBuffer();\n  u8g2.setFont(u8g2_font_6x12_tr);\n  u8g2.drawStr(0, 10, "Serigrafi Makinesi");\n  for (byte i=0; i<MENU_COUNT; i++) {\n    if (i == mainMenuIndex) u8g2.drawStr(0, 20+12*i, ">");\n    u8g2.drawStr(10, 20+12*i, mainMenuTexts[i]);\n  }\n  u8g2.drawStr(0, 58, "Menu: Enkoder bas");\n  u8g2.sendBuffer();\n}\n\n/************* OTOMATİK MOD (Baskı Döngüsü) ***********/\nvoid otomatikModu() {\n  static bool ilk = true;\n  static byte adim = 0;\n  static bool stepOK = true;\n\n  if (ilk) {\n    tumPistonlarYukari();\n    strcpy(statusMsg, "Pedal Bekleniyor");\n    ilk = false;\n    adim = 0;\n    donusYon = 0;\n  }\n  // Pedal bekleniyor\n  if (adim == 0) {\n    showOtoStatus("Bekliyor", "");\n    if (digitalRead(pedalButon) == LOW) {\n      strcpy(statusMsg, "Calisiyor");\n      adim = 1; delay(100);\n    }\n  }\n  // Ana piston asagi\n  else if (adim == 1) {\n    anaPistonAsagi();\n    showOtoStatus("Ana Piston Iniyor", "");\n    if (!waitSensor(anaPistonAsagiSensor, "AnaP Down")) { hataDur("AnaP Down Hata"); ilk = true; adim=0; state=ERROR; return; }\n    delay(pistonTime);\n    adim = 2;\n  }\n  // Ragle asagi\n  else if (adim == 2) {\n    raglePistonAsagi();\n    showOtoStatus("Ragle Iniyor", "");\n    if (!waitSensor(raglePistonAsagiSensor, "Ragle Down")) { hataDur("Ragle Down Hata"); ilk = true; adim=0; state=ERROR; return; }\n    delay(ragleTime);\n    adim = 3;\n  }\n  // Step motor hareketi\n  else if (adim == 3) {\n    if (donusYon == 0) {\n      stepMotorHareket('L');\n      stepOK = moveStepUntil(stepSolSensor, stepDist, "Step Sola Gidiyor");\n    } else {\n      stepMotorHareket('R');\n      stepOK = moveStepUntil(stepSagSensor, stepDist, "Step Saga Gidiyor");\n    }\n    if (!stepOK) { ilk = true; adim=0; state=ERROR; return; }\n    adim = 4;\n  }\n  // Pistonlar yukari\n  else if (adim == 4) {\n    tumPistonlarYukari();\n    showOtoStatus("Pistonlar Yukari", "");\n    if (!waitSensor(anaPistonYukariSensor, "AnaP Up") || !waitSensor(raglePistonYukariSensor, "Ragle Up")) {\n      hataDur("Piston Yukari Hata"); ilk = true; adim=0; state=ERROR; return;\n    }\n    donusYon = !donusYon;\n    strcpy(statusMsg, "Pedal Bekleniyor");\n    adim = 0;\n  }\n  // Ana menüye dönmek için enkoder tuşu\n  ClickEncoder::Button b = encoder.getButton();\n  if (b == ClickEncoder::Clicked) { ilk = true; adim=0; state = MAIN_MENU; delay(200);}\n}\n\n/*************** TEST MODU **********************/\nconst char* testMenuItems[] = {\n  "AnaP DOWN", "AnaP UP", "Ragle DOWN", "Ragle UP", "Step LEFT", "Step RIGHT"\n};\n#define TEST_MENU_COUNT 6\nvoid testModu() {\n  // Menüde hareket seçimi\n  int16_t enc = encoder.getValue();\n  if (enc != encLast) {\n    int diff = enc - encLast;\n    encLast = enc;\n    testMenuIndex = (testMenuIndex + diff + TEST_MENU_COUNT) % TEST_MENU_COUNT;\n  }\n  ClickEncoder::Button b = encoder.getButton();\n  if (b == ClickEncoder::Clicked) {\n    switch(testMenuIndex) {\n      case 0: anaPistonAsagi();   break;\n      case 1: anaPistonYukari();  break;\n      case 2: raglePistonAsagi(); break;\n      case 3: raglePistonYukari(); break;\n      case 4: stepMotorHareket('L'); for (int i=0; i<50; i++) {stepMotorStep(); delayMicroseconds(stepSpeed);} break;\n      case 5: stepMotorHareket('R'); for (int i=0; i<50; i++) {stepMotorStep(); delayMicroseconds(stepSpeed);} break;\n    }\n    delay(200);\n  }\n  // Ana menüye dönmek için enkoder tuşu uzun basım (Held)\n  if (b == ClickEncoder::Held) { state = MAIN_MENU; delay(300); }\n\n  // LCD: Test menüsü ve sensör izleme\n  u8g2.clearBuffer();\n  u8g2.setFont(u8g2_font_6x12_tr);\n  u8g2.drawStr(0,10,"TEST MODU");\n  for (byte i=0; i<TEST_MENU_COUNT; i++) {\n    if (i == testMenuIndex) u8g2.drawStr(0, 20+12*i, ">");\n    u8g2.drawStr(10, 20+12*i, testMenuItems[i]);\n  }\n  // Sensör durumları (0/1)\n  char buf[32];\n  sprintf(buf, "APUp:%d", digitalRead(anaPistonYukariSensor) ? 1 : 0);\n  u8g2.drawStr(90, 12, buf);\n  sprintf(buf, "APDn:%d", digitalRead(anaPistonAsagiSensor) ? 1 : 0);\n  u8g2.drawStr(90, 24, buf);\n  sprintf(buf, "RGUp:%d", digitalRead(raglePistonYukariSensor) ? 1 : 0);\n  u8g2.drawStr(90, 36, buf);\n  sprintf(buf, "RGDn:%d", digitalRead(raglePistonAsagiSensor) ? 1 : 0);\n  u8g2.drawStr(90, 48, buf);\n  sprintf(buf, "SL:%d SR:%d", digitalRead(stepSolSensor) ? 1 : 0, digitalRead(stepSagSensor) ? 1 : 0);\n  u8g2.drawStr(90, 60, buf);\n\n  u8g2.sendBuffer();\n}\n\n/*************** AYAR MENÜSÜ ********************/\nvoid ayarMenusu() {\n  int16_t enc = encoder.getValue();\n  if (enc != encLast) {\n    int diff = enc - encLast;\n    encLast = enc;\n    switch(ayarMenuIndex) {\n      case 0: stepSpeed = constrain(stepSpeed + diff*10, 100, 2000); break;\n      case 1: stepDist  = constrain(stepDist + diff*10, 10, 10000); break;\n      case 2: ragleTime = constrain(ragleTime + diff*10, 10, 1000); break;\n      case 3: pistonTime = constrain(pistonTime + diff*10, 10, 1000); break;\n    }\n  }\n  ClickEncoder::Button b = encoder.getButton();\n  if (b == ClickEncoder::Clicked) {\n    // Ayarı kaydetmeden önce index'i ilerletiyoruz (orijinal mantık korunmuştur)\n    ayarMenuIndex = (ayarMenuIndex + 1) % AYAR_MENU_COUNT;\n    // Ayarı kaydet\n    switch((ayarMenuIndex + AYAR_MENU_COUNT - 1) % AYAR_MENU_COUNT) { // önceki seçili elemanı kaydet\n      case 0: EEPROMWriteInt(EEPROM_STEP_SPEED_ADDR, stepSpeed); break;\n      case 1: EEPROMWriteInt(EEPROM_STEP_DIST_ADDR, stepDist); break;\n      case 2: EEPROMWriteInt(EEPROM_RAGLE_TIME_ADDR, ragleTime); break;\n      case 3: EEPROMWriteInt(EEPROM_PISTON_TIME_ADDR, pistonTime); break;\n    }\n    delay(200);\n  }\n  // Ana menüye dönmek için enkoder tuşu uzun basım (Held)\n  if (b == ClickEncoder::Held) { state = MAIN_MENU; delay(300); }\n  // LCD\n  u8g2.clearBuffer();\n  u8g2.setFont(u8g2_font_6x12_tr);\n  char buf[32];\n  sprintf(buf, "%s %u", ayarMenuNames[ayarMenuIndex], getMenuValue(ayarMenuIndex));\n  u8g2.drawStr(0, 12, buf);\n  u8g2.drawStr(0, 28, "Menu: Enkoder bas");\n  u8g2.drawStr(0, 44, "Deger: Cevir");\n  u8g2.drawStr(0, 60, "Geri: Uzun bas");\n  u8g2.sendBuffer();\n}\n\n/*************** HATA EKRANI ********************/\nvoid hataEkrani() {\n  u8g2.clearBuffer();\n  u8g2.setFont(u8g2_font_6x12_tr);\n  u8g2.drawStr(0, 20, "HATA OLUSTU!");\n  u8g2.drawStr(0, 36, statusMsg);\n  u8g2.drawStr(0, 54, "Pedala bas: Devam");\n  u8g2.sendBuffer();\n  // Pedal ile resetle\n  if (digitalRead(pedalButon) == LOW) {\n    state = MAIN_MENU;\n    strcpy(statusMsg, "Hazir");\n    delay(200);\n  }\n}\n\n/******************* Yardımcı Fonksiyonlar ********************/\n\n// Otomatik modda adım adım durum\nvoid showOtoStatus(const char* adim, const char* ek) {\n  u8g2.clearBuffer();\n  u8g2.setFont(u8g2_font_6x12_tr);\n  u8g2.drawStr(0, 10, "Otomatik Mod");\n  u8g2.drawStr(0, 26, adim);\n  u8g2.drawStr(0, 42, statusMsg);\n  u8g2.sendBuffer();\n}\n\n// Sensörden bekleme fonksiyonu (timeout kontrollü)\nbool waitSensor(int pin, const char* msg) {\n  unsigned long start = millis();\n  while (digitalRead(pin) == LOW) {\n    showOtoStatus(msg, "");\n    if (millis() - start > 4000) return false; // 4sn timeout\n    // küçük bir bekleme, simülasyonda CPU maliyetini azaltır\n    delay(5);\n  }\n  return true;\n}\n\n// Step motor hareket fonksiyonu (güvenlikli)\nbool moveStepUntil(int sensorPin, unsigned int maxStep, const char* msg) {\n  unsigned int i = 0;\n  while (digitalRead(sensorPin) == LOW && i < maxStep) {\n    stepMotorStep();\n    delayMicroseconds(stepSpeed);\n    i++;\n    showOtoStatus(msg, "");\n  }\n  if (digitalRead(sensorPin) == HIGH) {\n    return true;\n  } else {\n    hataDur("Step/Sensor HATA");\n    return false;\n  }\n}\n\nvoid hataDur(const char* msg) {\n  strncpy(statusMsg, msg, sizeof(statusMsg)-1);\n  statusMsg[sizeof(statusMsg)-1] = '\0';\n  state = ERROR;\n}\n\n// Ayar menüsünde değeri döndür\nunsigned int getMenuValue(byte idx) {\n  switch(idx) {\n    case 0: return stepSpeed;\n    case 1: return stepDist;\n    case 2: return ragleTime;\n    case 3: return pistonTime;\n    default: return 0;\n  }\n}\n\n// EEPROM okuma/yazma (kısa int)\nvoid EEPROMWriteInt(int address, int value) {\n  byte lowByte = value & 0xFF;\n  byte highByte = (value >> 8) & 0xFF;\n  EEPROM.write(address, lowByte);\n  EEPROM.write(address + 1, highByte);\n}\nint EEPROMReadInt(int address, int defaultValue) {\n  byte lowByte = EEPROM.read(address);\n  byte highByte = EEPROM.read(address + 1);\n  int val = (highByte << 8) | lowByte;\n  // EEPROM boşsa 0xFFFF dönüyor olabilir; buna karşı default döndür\n  if (val == 0xFFFF || val == 0x0000) return defaultValue;\n  return val;\n}\n\n// Piston ve step motor kontrolleri\nvoid anaPistonAsagi() {\n  digitalWrite(anaPistonA, LOW);\n  digitalWrite(anaPistonB, HIGH);\n}\nvoid anaPistonYukari() {\n  digitalWrite(anaPistonA, HIGH);\n  digitalWrite(anaPistonB, LOW);\n}\nvoid raglePistonAsagi() {\n  digitalWrite(raglePistonA, LOW);\n  digitalWrite(raglePistonB, HIGH);\n}\nvoid raglePistonYukari() {\n  digitalWrite(raglePistonA, HIGH);\n  digitalWrite(raglePistonB, LOW);\n}\nvoid tumPistonlarYukari() {\n  anaPistonYukari();\n  raglePistonYukari();\n}\nvoid stepMotorHareket(char yon) {\n  digitalWrite(dirPin, yon == 'L' ? LOW : HIGH);\n}\nvoid stepMotorStep() {\n  digitalWrite(stepPin, HIGH);\n  delayMicroseconds(2);\n  digitalWrite(stepPin, LOW);\n  delayMicroseconds(2);\n}","components": [{"type": "display-128x64-st7920", "id": "lcd0", "connections": {"cs": "10", "din": "11", "clk": "13", "vcc": "5V", "gnd": "GND"}}, {"type": "rotary-encoder", "id": "enc0", "connections": {"a": "31", "b": "33", "sw": "35"}}, {"type": "button", "id": "btn_pedal", "connections": {"a": "8", "b": "GND"}}, {"type": "led", "id": "led_step", "connections": {"anode": "26", "cathode": "GND"}}]}